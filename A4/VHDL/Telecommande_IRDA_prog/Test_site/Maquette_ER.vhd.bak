
--=======================================================
--  This code is generated by Terasic System Builder
--=======================================================
library ieee;
use ieee.std_logic_1164.all ;


entity Maquette_ER is
	port (

			--//////////// CLOCK //////////
			CLOCK_50, CLOCK2_50, CLOCK3_50 	:	in		std_logic ;

			--//////////// LED //////////
			LEDG										:	out	std_logic_vector(8 downto 0) ;
			LEDR										:	out	std_logic_vector(17 downto 0) ;

			--//////////// KEY //////////
			KEY										:	in		std_logic_vector(3 downto 0) ;

			--//////////// SW //////////
			SW											:	in		std_logic_vector(17 downto 0) ;

			--//////////// SEG7 //////////
			HEX0,	HEX1,	HEX2,	HEX3,	HEX4,	HEX5,	HEX6,	HEX7 : out	std_logic_vector(6 downto 0) ;

			--//////////// LCD //////////
			LCD_BLON, LCD_EN,	LCD_ON, LCD_RS, LCD_RW : out std_logic ;
			LCD_DATA									:	inout	std_logic_vector(7 downto 0) ;

			--//////////// SDCARD //////////
			SD_CLK									:	out 	std_logic ;
			SD_CMD									:	inout std_logic ;
			SD_DAT									:	inout std_logic_vector(3 downto 0) ;
			SD_WP_N									:	in 	std_logic ;

			--//////////// VGA //////////
			VGA_B, VGA_G, VGA_R					:	out	std_logic_vector(7 downto 0) ;
			VGA_BLANK_N, VGA_CLK					:	out	std_logic ;
			VGA_HS, VGA_SYNC_N, VGA_VS			:	out	std_logic ;

			--//////////// Audio //////////
			AUD_ADCDAT								:	in		std_logic ;
			AUD_ADCLRCK, AUD_BCLK, AUD_DACLRCK : inout std_logic ;
			AUD_DACDAT, AUD_XCK					:	out	std_logic ;

			--//////////// I2C for Audio HSMC  //////////
			I2C_SCLK									:	out	std_logic ;
			I2C_SDAT									:	inout	std_logic ;

			--//////////// IR Receiver //////////
			IRDA_RXD									:	in 	std_logic ;

			--//////////// SRAM //////////
			SRAM_ADDR								:	out	std_logic_vector(19 downto 0) ;
			SRAM_DQ									:	inout std_logic_vector(15 downto 0) ;
			SRAM_CE_N, SRAM_LB_N, SRAM_OE_N	:	out	std_logic ;
			SRAM_UB_N, SRAM_WE_N					:	out	std_logic ;

			--//////////// GPIO, GPIO connect to GPIO Default //////////
			GPIO										:	inout std_logic_vector(35 downto 0) ;

			--//////////// HSMC, HSMC connect to HSMC Expansion - 3.3V //////////
			HSMC_CLKIN0, HSMC_CLKIN_N1, HSMC_CLKIN_P1	:	in 	std_logic ;
			HSMC_CLKIN_N2, HSMC_CLKIN_P2		:	in 	std_logic ;
			HSMC_CLKOUT_N1, HSMC_CLKOUT_P1, HSMC_CLKOUT0	:	inout	std_logic ;
			HSMC_CLKOUT_N2, HSMC_CLKOUT_P2	:	inout	std_logic ;
			HSMC_D									:	inout std_logic_vector(3 downto 0) ;
			HSMC_RX_D_N								:	inout std_logic_vector(16 downto 0) ;
			HSMC_RX_D_P								:	inout std_logic_vector(16 downto 0) ;
			HSMC_TX_D_N								:	inout std_logic_vector(16 downto 0) ;
			HSMC_TX_D_P								:	inout std_logic_vector(16 downto 0) 
			) ;
end entity Maquette_ER ;

architecture synth of Maquette_ER is

	component pll
		port
		(
			inclk0		: IN std_logic  := '0';
			c0		: OUT std_logic 
		);
	end component;

	component telemetre_dist is
		port (	arazb,clk			: in std_logic ;
				inter				: in std_logic_vector(17 downto 0) ;
				reception,erreur	: in std_logic ;
				temperature			: in std_logic_vector(4 downto 0) ;
				cde_em1, cde_em2		: out std_logic ;
				ssb_aff, ssb_pot, sclk, mosi,depass_out	: out std_logic ;
				dist_7seg		: out std_logic_vector (8 downto 0) ;
				led_rouges			: out std_logic_vector(17 downto 0)	
			) ;
	end component;

	component recepteur is
		port (	arazb,clk : in std_logic ;
				bit_data : in std_logic ;
				duree_bit : in integer range 0 to 8333 ;
				temperature : out std_logic_vector(7 downto 0) ;
				ok,erreur : out std_logic
			) ;
	end component ;
	
	component test_conv is
		port (
				arazb,clk_10mhz	:	in std_logic ;
				
				inter			:	in std_logic_vector (17 downto 0) ;
				fact_div		:	integer range 0 to 1000 ;
				
				ssb_cna, sclk_cna, mosi_cna	:	out std_logic;
				ssb_can, sclk_can, mosi_can	:	out std_logic;
				miso_can			:	in std_logic 
				
			) ;
	end component ;
	
	
	component bintobcd_10bits IS
	PORT (	
		ck 			:	IN  STD_LOGIC;
		arazb 		:  IN  STD_LOGIC;
		binary		:	IN  STD_LOGIC_VECTOR(9 downto 0);
		
		BCD_uni		:  OUT  STD_LOGIC_VECTOR(3 downto 0);
		BCD_diz		:  OUT  STD_LOGIC_VECTOR(3 downto 0);
		BCD_cen		:  OUT  STD_LOGIC_VECTOR(3 downto 0)
		);
	end component bintobcd_10bits;

	component deco7seg IS 
		PORT
		(
		-- Entrees
			E 			:  	IN  STD_LOGIC_VECTOR(3 downto 0);
			comp			:		IN  STD_LOGIC;
		-- Sorties	
			Segm		:		OUT STD_LOGIC_VECTOR(6 downto 0)	
		);
	END component;
	

	signal clk_10mhz : std_logic ;

	signal pulse_in, recep, em_1, em_2, shutdown : std_logic ;

	signal ssb_aff, sclk_aff, mosi_aff, miso_aff : std_logic ;
	signal ssb_pot, sclk_pot, mosi_pot : std_logic ;

	signal ssb_cna, sclk_cna, mosi_cna	:	 std_logic;
	signal ssb_can, sclk_can, mosi_can,miso_can	:	 std_logic;

	
	SIGNAL	imosi, isclk, recep_sync :  STD_LOGIC;
	signal temp : std_logic_vector (7 downto 0);
	signal dist : 	std_logic_vector (8 downto 0) ;
	signal aff_c,aff_d,aff_u : std_LOGIC_VECTOR (3 downto 0) ;

	signal bit_data_sync, err : std_logic ;



begin

	le_test : test_conv 
		port map (
			arazb => key(0),
			clk_10mhz => clk_10MHZ,
			
			inter => SW,
			fact_div => 250,
			
			ssb_cna => ssb_cna,
			sclk_cna => sclk_cna,
			mosi_cna => mosi_cna	,
			
			ssb_can => ssb_can,
			sclk_can => sclk_can,
			mosi_can => mosi_can	,
			miso_can => miso_can
			
		) ;


-- utiliser le modele ci-dessous pour instancier votre composant telemetre :
	mon_telemetre : telemetre_dist
	PORT MAP(
			arazb 		=>  key(0),
			clk			=>  clk_10MHz,
			reception 	=> recep_sync,
			erreur		=> err,				-- erreur de reception HF
			temperature => temp(4 downto 0),
			inter 		=> SW,
			cde_em1 	=>  em_1,
			cde_em2 	=>  em_2,
			mosi 		=> imosi,
			depass_out => ledG(0),
			sclk 		=>  isclk,
			ssb_pot 	=>  ssb_pot,
			dist_7seg => dist,
			ssb_aff	 =>  ssb_aff
		);
		
		
-- NE PAS MODIFIER CE QUI SUIT !		

-- connexions leds rouges
	ledr <= sw ;
	ledG(8 downto 1) <= (others => '0') ;

-- connexions spi potentiometre et afficheur
	mosi_aff <= imosi ;
	mosi_pot		 <= imosi ;
	sclk_aff <= isclk ;
	sclk_pot	 <= isclk ;

-- instanciations convertisseur binaire / 3 7seg
	mon_deco : bintobcd_10bits
		port map (
			ck 			=>  clk_10MHz,
			arazb 		=>  key(0),
			binary		=> '0'&dist,		
			BCD_uni		=> aff_u,
			BCD_diz		=> aff_d,
			BCD_cen		=> aff_c
		);
		
	deco_u : deco7seg
		port map (
			E			=> 	aff_u,
			comp		=>		'1',
			segm		=>		hex0		
		);
	deco_d : deco7seg
		port map (
			E			=> 	aff_d,
			comp		=>		'1',
			segm		=>		hex1	
		);
	deco_c : deco7seg
		port map (
			E			=> 	aff_c,
			comp		=>		'1',
			segm		=>		hex2
		);
	hex3 <= (others => '1') ;
	hex4 <= (others => '1') ;
	hex5 <= (others => '1') ;
	hex6 <= (others => '1') ;
	hex7 <= (others => '1') ;
	

-- connexions convertisseurs
	miso_can <= HSMC_TX_D_N(15);
	hsmc_tx_D_P(15) <= mosi_can ;
	HSMC_TX_D_P(16) <= sclk_can ;
	hsmc_tx_D_N(16) <= ssb_can ;
	
	hsmc_rx_D_n(16) <= sclk_cna ;
	hsmc_rx_D_p(16) <= mosi_cna ;
	hsmc_rx_D_n(15) <= ssb_cna ;

--	ssb_cna <= '1';
--	sclk_cna <= '1';
--	mosi_cna	 <= '1';
--	
--	ssb_can <= '1';
--	sclk_can <= '1';
--	mosi_can	 <= '1';
--	miso_can <= '1';
	
-- instanciation pll
	pll_inst : pll port map (
			inclk0	 => CLOCK_50,
			c0	 => clk_10mhz
		);
	
			
		
-- connexions Telemetre
	pulse_in <= HSMC_rx_D_n(9) ;		-- recepteur HF
	
	recep		<= HSMc_tx_D_N(12) ;
	HSMC_CLKOUT_P2 <= em_1 ;
	HSMc_tx_D_n(13)  <=  em_2 ;
	HSMc_tx_D_p(13) <= shutdown ;
	
	HSMc_tX_D_P(10) <= ssb_aff ;
	HSMc_TX_D_P(9) <= sclk_aff ;
	HSMc_TX_D_N(10) <= mosi_aff ;
	miso_aff <= HSMc_TX_D_N(9) ;
	
	HSMc_TX_D_P(12) <= ssb_pot ;
	HSMc_TX_D_P(14) <= sclk_pot ;
	HSMC_CLKOUT_N2 <= mosi_pot ;
		
	-- synchro entrees externes	
	PROCESS(clk_10MHZ, key(0))
	BEGIN
		IF key(0)='0' THEN recep_sync <= '0';
			ELSIF clk_10MHZ'EVENT and clk_10MHZ='1' THEN
				recep_sync <= recep ;
				bit_data_sync <= pulse_in ;
		END IF;
	END PROCESS;

-- commande élévateur de tension
	shutdown <= sw(10);

-- instanciation recepteur HF	
	mon_recepteur : recepteur 
	port map	(	arazb 		=>  key(0),
					clk			=>  clk_10MHz,

					bit_data 	=>	bit_data_sync ,
					duree_bit 	=>	5000,
					temperature => temp,
					ok			=> open,
					erreur 		=> err
			) ;
-- ou :
--	temp <= "000"&sw(17 downto 13) ;
--	err <= '0' ;



end ;

